load ../msh.maude

set include BOOL off .

fmod TEST-MODULE is
  sorts A B .
  subsort A < B .

  op a : -> A .
  op b : -> B .

  op f : B -> A .
  ---------------
  eq f(b) = a .
endfm

fmod TEST-MODULE2 is
  sorts C D .
  subsort C < D .

  op c : -> C .
  op d : -> D .

  op g : C -> D .
  ---------------
  eq g(c) = d .
endfm

fmod EMPTY is endfm

select MSH .
set print color on .

reduce

claim [ ( modules < .ModuleEnv >
          strategy < load-module('TEST-MODULE)
                   ; set-module('TEST-MODULE-LIST, ('TEST-MODULE deriving LIST))
                   ; show-module('TEST-MODULE-LIST)
                   >
          output < .Output >
        )

      reduces-to

        ( modules < 'TEST-MODULE |-> 'TEST-MODULE 'TEST-MODULE-LIST |-> ('TEST-MODULE deriving LIST)>
          strategy < .Program >
          output < show-module( fmod 'TEST-MODULE is
                                  nil
                                  sorts 'A ; 'B ; 'List`{A`} ; 'List`{B`} ; 'NeList`{A`} ; 'NeList`{B`} .
                                  subsort 'A < 'B .
                                  subsort 'A < 'NeList`{A`} .
                                  subsort 'B < 'NeList`{B`} .
                                  subsort 'List`{A`} < 'List`{B`} .
                                  subsort 'NeList`{A`} < 'List`{A`} .
                                  subsort 'NeList`{A`} < 'NeList`{B`} .
                                  subsort 'NeList`{B`} < 'List`{B`} .
                                  op '.List : nil -> 'List`{A`} [ctor] .
                                  op '.List : nil -> 'List`{B`} [ctor] .
                                  op '_`,_ : 'List`{A`} 'List`{A`} -> 'List`{A`} [assoc ctor id('.List.List`{A`})] .
                                  op '_`,_ : 'List`{A`} 'NeList`{A`} -> 'NeList`{A`} [assoc ctor id('.List.List`{A`})] .
                                  op '_`,_ : 'List`{B`} 'List`{B`} -> 'List`{B`} [assoc ctor id('.List.List`{B`})] .
                                  op '_`,_ : 'List`{B`} 'NeList`{B`} -> 'NeList`{B`} [assoc ctor id('.List.List`{B`})] .
                                  op 'a : nil -> 'A [none] .
                                  op 'b : nil -> 'B [none] .
                                  op 'f : 'B -> 'A [none] .
                                  none
                                  eq 'f['b.B] = 'a.A [none] .
                                endfm
                              )
                 >
        )
      ]

.

reduce

claim [ ( modules < .ModuleEnv >
          strategy < load-module('TEST-MODULE)
                   ; set-module('TEST-MODULE-SET, ('TEST-MODULE deriving SET))
                   ; show-module('TEST-MODULE-SET)
                   >
          output < .Output >
        )

      reduces-to

        ( modules < 'TEST-MODULE |-> 'TEST-MODULE 'TEST-MODULE-SET |-> ('TEST-MODULE deriving SET)>
          strategy < .Program >
          output < show-module( fmod 'TEST-MODULE is
                                  nil
                                  sorts 'A ; 'B ; 'NeSet`{A`} ; 'NeSet`{B`} ; 'Set`{A`} ; 'Set`{B`} .
                                  subsort 'A < 'B .
                                  subsort 'A < 'NeSet`{A`} .
                                  subsort 'B < 'NeSet`{B`} .
                                  subsort 'NeSet`{A`} < 'NeSet`{B`} .
                                  subsort 'NeSet`{A`} < 'Set`{A`} .
                                  subsort 'NeSet`{B`} < 'Set`{B`} .
                                  subsort 'Set`{A`} < 'Set`{B`} .
                                  op '.Set : nil -> 'Set`{A`} [ctor] .
                                  op '.Set : nil -> 'Set`{B`} [ctor] .
                                  op '_;_ : 'Set`{A`} 'NeSet`{A`} -> 'NeSet`{A`} [assoc comm ctor id('.Set.Set`{A`})] .
                                  op '_;_ : 'Set`{A`} 'Set`{A`} -> 'Set`{A`} [assoc comm ctor id('.Set.Set`{A`})] .
                                  op '_;_ : 'Set`{B`} 'NeSet`{B`} -> 'NeSet`{B`} [assoc comm ctor id('.Set.Set`{B`})] .
                                  op '_;_ : 'Set`{B`} 'Set`{B`} -> 'Set`{B`} [assoc comm ctor id('.Set.Set`{B`})] .
                                  op 'a : nil -> 'A [none] .
                                  op 'b : nil -> 'B [none] .
                                  op 'f : 'B -> 'A [none] .
                                  none
                                  eq '_;_['NeS`{A`}:NeSet`{A`},'NeS`{A`}:NeSet`{A`}] = 'NeS`{A`}:NeSet`{A`} [none] .
                                  eq '_;_['NeS`{B`}:NeSet`{B`},'NeS`{B`}:NeSet`{B`}] = 'NeS`{B`}:NeSet`{B`} [none] .
                                  eq 'f['b.B] = 'a.A [none] .
                                endfm
                              )
                 >
        )
      ]

.

reduce

claim [ ( modules  < .ModuleEnv >
          strategy < load-module('TEST-MODULE)
                   ; set-module('STATE, 'TEST-MODULE deriving LIST)
                   ; reduce
                   >
          state    < '_`,_['a.A, 'a.A, 'b.B, 'b.B, 'f['b.B]] >
        )

      reduces-to

        ( modules  < 'TEST-MODULE |-> 'TEST-MODULE 'STATE |-> ('TEST-MODULE deriving LIST) >
          strategy < .Program >
          state    < '_`,_['a.A, 'a.A, 'b.B, 'b.B, 'a.A] >
        )
      ]

.

reduce

claim [ ( modules  < .ModuleEnv >
          strategy < load-module('TEST-MODULE)
                   ; set-module('STATE, 'TEST-MODULE deriving SET)
                   ; reduce
                   >
          state    < '_;_['a.A, 'a.A, 'b.B, 'b.B, 'f['b.B]] >
        )

      reduces-to

        ( modules  < 'TEST-MODULE |-> 'TEST-MODULE 'STATE |-> ('TEST-MODULE deriving SET) >
          strategy < .Program >
          state    < '_;_['a.A, 'b.B] >
        )
      ]

.

reduce

claim [ ( modules  < .ModuleEnv >
          strategy < load-module('TEST-MODULE)
                   ; set-module('TEST-MODULE-META-THEORY, 'TEST-MODULE deriving META-THEORY)
                   ; show-module('TEST-MODULE-META-THEORY)
                   >
          output   < .Output >
        )

      reduces-to

        ( modules  < 'TEST-MODULE |-> 'TEST-MODULE 'TEST-MODULE-META-THEORY |-> ('TEST-MODULE deriving META-THEORY) >
          strategy < .Program >
          output   < show-module( fmod 'TEST-MODULE is
                                    protecting 'QID .
                                    extending 'META-LEVEL .
                                    sorts 'A ; 'Assignment ; 'Assignment`{TEST-MODULE`} ; 'B ; 'Constant ; 'Constant`{TEST-MODULE`} ; 'Context ; 'Context`{TEST-MODULE`}
                                        ; 'GTermList ; 'GTermList`{TEST-MODULE`} ; 'GroundTerm ; 'GroundTermList ; 'GroundTermList`{TEST-MODULE`} ; 'GroundTerm`{TEST-MODULE`}
                                        ; 'Kind ; 'Kind`{TEST-MODULE`} ; 'NeCTermList ; 'NeCTermList`{TEST-MODULE`} ; 'NeGroundTermList ; 'NeGroundTermList`{TEST-MODULE`}
                                        ; 'NeTermList ; 'NeTermList`{TEST-MODULE`} ; 'Sort ; 'Sort`{TEST-MODULE`} ; 'Substitution ; 'Substitution`{TEST-MODULE`} ; 'Term ; 'TermList
                                        ; 'TermList`{TEST-MODULE`} ; 'TermQid ; 'TermQid`{TEST-MODULE`} ; 'Term`{TEST-MODULE`} ; 'Type ; 'Type`{TEST-MODULE`} ; 'Variable ; 'Variable`{TEST-MODULE`} .
                                    subsort 'A < 'B .
                                    subsort 'Assignment < 'Substitution .
                                    subsort 'Assignment`{TEST-MODULE`} < 'Assignment .
                                    subsort 'Assignment`{TEST-MODULE`} < 'Substitution`{TEST-MODULE`} .
                                    subsort 'Constant < 'GroundTerm .
                                    subsort 'Constant < 'TermQid .
                                    subsort 'Constant`{TEST-MODULE`} < 'Constant .
                                    subsort 'Constant`{TEST-MODULE`} < 'GroundTerm`{TEST-MODULE`} .
                                    subsort 'Constant`{TEST-MODULE`} < 'TermQid`{TEST-MODULE`} .
                                    subsort 'Context < 'NeCTermList .
                                    subsort 'Context`{TEST-MODULE`} < 'Context .
                                    subsort 'Context`{TEST-MODULE`} < 'NeCTermList`{TEST-MODULE`} .
                                    subsort 'GTermList`{TEST-MODULE`} < 'GTermList .
                                    subsort 'GroundTerm < 'NeGroundTermList .
                                    subsort 'GroundTerm < 'Term .
                                    subsort 'GroundTermList < 'TermList .
                                    subsort 'GroundTermList`{TEST-MODULE`} < 'GroundTermList .
                                    subsort 'GroundTermList`{TEST-MODULE`} < 'TermList`{TEST-MODULE`} .
                                    subsort 'GroundTerm`{TEST-MODULE`} < 'GroundTerm .
                                    subsort 'GroundTerm`{TEST-MODULE`} < 'NeGroundTermList`{TEST-MODULE`} .
                                    subsort 'GroundTerm`{TEST-MODULE`} < 'Term`{TEST-MODULE`} .
                                    subsort 'Kind < 'Type .
                                    subsort 'Kind`{TEST-MODULE`} < 'Kind .
                                    subsort 'Kind`{TEST-MODULE`} < 'Type`{TEST-MODULE`} .
                                    subsort 'NeCTermList < 'GTermList .
                                    subsort 'NeCTermList`{TEST-MODULE`} < 'GTermList`{TEST-MODULE`} .
                                    subsort 'NeCTermList`{TEST-MODULE`} < 'NeCTermList .
                                    subsort 'NeGroundTermList < 'GroundTermList .
                                    subsort 'NeGroundTermList < 'NeTermList .
                                    subsort 'NeGroundTermList`{TEST-MODULE`} < 'GroundTermList`{TEST-MODULE`} .
                                    subsort 'NeGroundTermList`{TEST-MODULE`} < 'NeGroundTermList .
                                    subsort 'NeGroundTermList`{TEST-MODULE`} < 'NeTermList`{TEST-MODULE`} .
                                    subsort 'NeTermList < 'TermList .
                                    subsort 'NeTermList`{TEST-MODULE`} < 'NeTermList .
                                    subsort 'NeTermList`{TEST-MODULE`} < 'TermList`{TEST-MODULE`} .
                                    subsort 'Sort < 'Type .
                                    subsort 'Sort`{TEST-MODULE`} < 'Sort .
                                    subsort 'Sort`{TEST-MODULE`} < 'Type`{TEST-MODULE`} .
                                    subsort 'Substitution`{TEST-MODULE`} < 'Substitution .
                                    subsort 'Term < 'NeTermList .
                                    subsort 'TermList < 'GTermList .
                                    subsort 'TermList`{TEST-MODULE`} < 'GTermList`{TEST-MODULE`} .
                                    subsort 'TermList`{TEST-MODULE`} < 'TermList .
                                    subsort 'TermQid < 'Qid .
                                    subsort 'TermQid < 'Term .
                                    subsort 'TermQid`{TEST-MODULE`} < 'TermQid .
                                    subsort 'TermQid`{TEST-MODULE`} < 'Term`{TEST-MODULE`} .
                                    subsort 'Term`{TEST-MODULE`} < 'NeTermList`{TEST-MODULE`} .
                                    subsort 'Term`{TEST-MODULE`} < 'Term .
                                    subsort 'Type < 'Qid .
                                    subsort 'Type`{TEST-MODULE`} < 'Type .
                                    subsort 'Variable < 'TermQid .
                                    subsort 'Variable`{TEST-MODULE`} < 'TermQid`{TEST-MODULE`} .
                                    subsort 'Variable`{TEST-MODULE`} < 'Variable .
                                    op '<Qids> : nil -> 'Constant [special(id-hook('QuotedIdentifierSymbol, 'constantQid))] .
                                    op '<Qids> : nil -> 'Kind [special(id-hook('QuotedIdentifierSymbol, 'kindQid))] .
                                    op '<Qids> : nil -> 'Sort [special(id-hook('QuotedIdentifierSymbol, 'sortQid))] .
                                    op '<Qids> : nil -> 'Variable [special(id-hook('QuotedIdentifierSymbol, 'variableQid))] .
                                    op '_;_ : 'Substitution 'Substitution -> 'Substitution [assoc comm ctor id('none.Substitution) prec(65)] .
                                    op '_<-_ : 'Variable 'Term -> 'Assignment [ctor prec(63) format('nt 'd 'd 'd)] .
                                    op '_`,_ : 'GTermList 'GTermList -> 'GTermList [assoc ctor id('empty.GroundTermList) prec(121) gather('e 'E)] .
                                    op '_`,_ : 'GroundTermList 'GroundTermList -> 'GroundTermList [assoc ctor id('empty.GroundTermList) prec(121) gather('e 'E)] .
                                    op '_`,_ : 'GroundTermList 'NeGroundTermList -> 'NeGroundTermList [assoc ctor id('empty.GroundTermList) prec(121) gather('e 'E)] .
                                    op '_`,_ : 'NeCTermList 'TermList -> 'NeCTermList [assoc ctor id('empty.GroundTermList) prec(121) gather('e 'E)] .
                                    op '_`,_ : 'NeGroundTermList 'GroundTermList -> 'NeGroundTermList [assoc ctor id('empty.GroundTermList) prec(121) gather('e 'E)] .
                                    op '_`,_ : 'NeTermList 'TermList -> 'NeTermList [assoc ctor id('empty.GroundTermList) prec(121) gather('e 'E)] .
                                    op '_`,_ : 'TermList 'NeCTermList -> 'NeCTermList [assoc ctor id('empty.GroundTermList) prec(121) gather('e 'E)] .
                                    op '_`,_ : 'TermList 'NeTermList -> 'NeTermList [assoc ctor id('empty.GroundTermList) prec(121) gather('e 'E)] .
                                    op '_`,_ : 'TermList 'TermList -> 'TermList [assoc ctor id('empty.GroundTermList) prec(121) gather('e 'E)] .
                                    op '_`[_`] : 'Qid 'NeCTermList -> 'Context [ctor] .
                                    op '_`[_`] : 'Qid 'NeGroundTermList -> 'GroundTerm [ctor] .
                                    op '_`[_`] : 'Qid 'NeTermList -> 'Term [ctor] .
                                    op '`[`] : nil -> 'Context [ctor] .
                                    op 'a : nil -> 'A [none] .
                                    op 'b : nil -> 'B [none] .
                                    op 'empty : nil -> 'GroundTermList [ctor] .
                                    op 'f : 'B -> 'A [none] .
                                    op 'getName : 'Constant -> 'Qid [none] .
                                    op 'getName : 'Variable -> 'Qid [none] .
                                    op 'getType : 'Constant -> 'Type [none] .
                                    op 'getType : 'Variable -> 'Type [none] .
                                    op 'none : nil -> 'Substitution [ctor] .
                                    cmb 'C:Constant : 'Constant`{TEST-MODULE`} if 'wellFormed['upModule[''TEST-MODULE.Sort,'true.Bool],'C:Constant] = 'true.Bool [none] .
                                    cmb 'GT:GroundTerm : 'GroundTerm`{TEST-MODULE`} if 'wellFormed['upModule[''TEST-MODULE.Sort,'true.Bool],'GT:GroundTerm] = 'true.Bool [none] .
                                    cmb 'T:Term : 'Term`{TEST-MODULE`} if 'wellFormed['upModule[''TEST-MODULE.Sort,'true.Bool],'T:Term] = 'true.Bool [none] .
                                    cmb 'V:Variable : 'Variable`{TEST-MODULE`} if 'wellFormed['upModule[''TEST-MODULE.Sort,'true.Bool],'V:Variable] = 'true.Bool [none] .
                                    eq '_;_['A:Assignment,'A:Assignment] = 'A:Assignment [none] .
                                    eq 'f['b.B] = 'a.A [none] .
                                    eq 'getName['C:Constant] = 'qid['substr['string['C:Constant],'0.Zero,'rfind['string['C:Constant],'".".Char,'length['string['C:Constant]]]]] [none] .
                                    eq 'getName['V:Variable] = 'qid['substr['string['V:Variable],'0.Zero,'rfind['string['V:Variable],'":".Char,'length['string['V:Variable]]]]] [none] .
                                    eq 'getType['C:Constant] = 'qid['substr['string['C:Constant],'_+_['s_['0.Zero],'rfind['string['C:Constant],'".".Char,'length['string['C:Constant]]]],'length['string['C:Constant]]]] [none] .
                                    eq 'getType['V:Variable] = 'qid['substr['string['V:Variable],'_+_['s_['0.Zero],'rfind['string['V:Variable],'":".Char,'length['string['V:Variable]]]],'length['string['V:Variable]]]] [none] .
                                  endfm
                                )
                 >
        )
      ]

.

--- todo:
--- fix arrow sorts, add qid construct for arrows
--- covariance/contravariance separately
--- subsorts arent what i think they are
--- do everything at double arrow level

fmod MODULE-EXPRESSION-EXP is
  protecting MODULE-EXPRESSION .

  op EXPONENTIAL : -> FreeConstruction .
  ----------------------------------------------
  eq EXPONENTIAL =   forall ( sorts svar('X) ; svar('Y) . )
                     exists ( sorts '=> < svar('X) svar('Y) > . )
                   ; forall ( sorts svar('X) ; svar('Y) ; svar('Z) ; svar('W) ;
                              '=> < svar('XY) > ; '=> < svar('ZW) > . )
                            ( subsorts svar('Y) < svar('W) ; svar('Z) < svar('X) . )
                     exists ( sorts none . )
                            ( subsort '=> < svar('XY) > < '=> < svar('ZW) > . )
                   ; forall ( sorts svar('X) ; svar('Y) ; ('=> < svar('XY) >) ; ('=> < svar('YZ) >) . )
                            ( op qvar('OP1) : svar('X) -> svar('Y) [none] .
                              op qvar('OP2) : svar('Y) -> svar('Z) [none] . )
                     exists ( sorts '=> < svar('XZ) > . )
                            ( op qvar('OP12) : svar('X) -> svar('Z) [none] . ) .

endfm

--- reduce #upModule('TEST-MODULE deriving EXPONENTIAL) .



fmod PURIFICATION is
    protecting MSH .
    protecting MODULE-EXPRESSION .

    op PURIFICATION : ModuleExpression ModuleExpression -> FreeConstruction .

    vars M1 M2          : ModuleExpression .
    vars TM TM' TM1 TM2 : Variable .

    ceq PURIFICATION(M1, M2)
      =   META-THEORY < M1 >
        ; META-THEORY < M2 >
        ; exists ( extending 'FOFORM .
                   extending M1 .
                   extending M2 . )
                 ( sorts none . )
                 ( op 'purify : 'EqAtom -> 'EqConj [none] .
                   op 'fvar   : 'Term 'Term -> 'Variable [none] . )
        ; forall ( sorts 'Term ; 'Term < svar('M) > . )
                 ( subsort 'Term < svar('M) > < 'Term . )
          exists ( sorts none . )
                 ( eq 'purify['_?=_[TM, TM']] = '_?=_[TM, TM'] [none] . )
        ; forall ( sorts 'Term ; 'Term < svar('M1) > ; 'Term < svar('M2) > . )
                 ( subsorts ('Term < svar('M1) >) ; ('Term < svar('M2) >) < 'Term . )
          exists ( sorts none . )
                 ( eq 'purify['_?=_[TM1, TM2]] = '_/\_['_?=_['fvar[TM1, TM2], TM1], '_?=_['fvar[TM1, TM2], TM2]] [none] . )

      if TM  := var('TM,  'Term < svar('M) >)
      /\ TM' := var('TM', 'Term < svar('M) >)
      /\ TM1 := var('TM1, 'Term < svar('M1) >)
      /\ TM2 := var('TM2, 'Term < svar('M2) >) .
endfm

reduce #resolveModule(#upModule('EMPTY deriving PURIFICATION('TEST-MODULE, 'TEST-MODULE2))) .
reduce wellFormed(#resolveModule(#upModule('EMPTY deriving PURIFICATION('TEST-MODULE, 'TEST-MODULE2)))) .

--- reduce reduce < #resolveModule(#upModule('EMPTY deriving PURIFICATION('TEST-MODULE, 'TEST-MODULE2))) > ['f['b.B]] .

--- set trace on .

reduce

claim [ ( modules  < .ModuleEnv >
          strategy < set-module('STATE, 'EMPTY deriving PURIFICATION('TEST-MODULE, 'TEST-MODULE2))
                   ; reduce
                   >
          state    < 'f['b.B] ;; 'g['c.C] ;; 'purify[upTerm('f['B:B] ?= 'f['A:A])] >
        )

      reduces-to

          ( modules  < 'STATE |-> ('EMPTY deriving PURIFICATION('TEST-MODULE, 'TEST-MODULE2)) >
          strategy < .Program >
          state    < 'a.A ;; 'd.D ;; '_?=_['_`[_`][''f.Sort, ''A:A.Variable`{TEST-MODULE`}], '_`[_`][''f.Sort, ''B:B.Variable`{TEST-MODULE`}]] >
        )
      ]

.

--- set trace off .    
