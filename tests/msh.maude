load ../msh.maude
load ../systems/all-systems.maude

set include BOOL off .

fmod TEST-MODULE is
  sorts A B .
  subsort A < B .

  op a : -> A .
  op b : -> B .

  op f : B -> A .
  ---------------
  eq f(b) = a .
endfm

--- fmod TEST-STUFF is
---   op initMOD : -> Module .
---   eq initMOD = ( fmod 'TEST-MODULE is
---                    nil
---                    sorts 'A ; 'B .
---                    subsort 'A < 'B .
---                    op 'a : nil -> 'A [none] .
---                    op 'b : nil -> 'B [none] .
---                    op 'f : 'B  -> 'A [none] .
---                    none
---                    eq 'f['b.B] = 'a.A [none] .
---                    none
---                  endfm
---                ) .
--- 
---   op origSorts : -> SortSet .
---   eq origSorts = 'A ; 'B .
--- 
---   op forallSorts : -> Term .
---   eq forallSorts = 'X:Sort .
---   op existsSorts : -> Term .
---   eq existsSorts = '_<_>[''List.Sort, 'X:Sort] .
--- 
---   op fc : -> FreeConstruction .
---   eq fc = forall forallSorts exists existsSorts .
--- 
---   op sxw : -> SubstitutionSet .
---   eq sxw = #subsumesXWith(upModule('META-LEVEL, true), forallSorts, upTerm(origSorts)) .
--- endfm

fmod MSH-TEST-HARNESS is
  extending MSH-EXTENDED .

  vars INIT CORRECT A A' : Analysis . var NeA : NeAnalysis .

  op claim : Analysis Analysis -> Analysis .
  op success : -> Analysis .

  op failure [_,_] : Analysis Analysis -> [Analysis] [format(d d n n n n d)].
  eq failure [ NeA A , NeA A' ] = failure [ A , A' ] .

  op _reduces-to_ : Analysis Analysis -> [Analysis] [prec 98].
  ------------------------------------------------------------
  eq NeA (A reduces-to A') = (NeA A) reduces-to (NeA A') .

  op claim [_] : Analysis -> [Analysis] .
  --------------------------------------
  ceq claim [ INIT reduces-to CORRECT ] = if A == CORRECT then success else failure [ CORRECT , INIT ] fi if A := INIT .
endfm

set print color on .

reduce

claim [ strategy < print("hello") >
        output < .Output >
      reduces-to
        strategy < .Program >
        output < print("hello") >
      ]
.

reduce

claim [ ( modules < .ModuleEnv >
          strategy < load-module('TEST-MODULE)
                   ; set-module('TEST-MODULE2, 'TEST-MODULE deriving forall 'X:Sort exists ('_<_>[''List.Sort, 'X:Sort]))
                   ; show-module('TEST-MODULE)
                   ; show-module('TEST-MODULE2)
                   >
          output < .Output >
        )

      reduces-to

        ( modules < 'TEST-MODULE |-> 'TEST-MODULE 'TEST-MODULE2 |-> ('TEST-MODULE deriving forall 'X:Sort exists ('_<_>[''List.Sort, 'X:Sort]))>
          strategy < .Program >
          output <   show-module( fmod 'TEST-MODULE is
                                    nil
                                    sorts 'A ; 'B .
                                    subsort 'A < 'B .
                                    op 'a : nil -> 'A [none] .
                                    op 'b : nil -> 'B [none] .
                                    op 'f : 'B  -> 'A [none] .
                                    none
                                    eq 'f['b.B] = 'a.A [none] .
                                    none
                                  endfm
                                )
                 ;;; show-module( fmod 'TEST-MODULE is
                                    nil
                                    sorts 'A ; 'B ; 'List`{A`} ; 'List`{B`} .
                                    subsort 'A < 'B .
                                    op 'a : nil -> 'A [none] .
                                    op 'b : nil -> 'B [none] .
                                    op 'f : 'B  -> 'A [none] .
                                    none
                                    eq 'f['b.B] = 'a.A [none] .
                                    none
                                  endfm
                                )
                 >
        )
      ]

.

reduce

claim [ modules < .ModuleEnv >
        strategy < load-module('CYCLE)
                 ; set-module('CYCLE-LIST, 'CYCLE deriving List('PreState))
                 ; show-module('CYCLE-LIST)
                 >
        output < .Output >
   
      reduces-to
       
        modules < 'CYCLE |-> 'CYCLE 'CYCLE-LIST |-> 'CYCLE deriving List('PreState) >
        strategy < .Program >
        output < show-module( mod 'CYCLE is
                                nil
                                sorts 'Bool ; 'List`{PreState`} ; 'NeList`{PreState`} ; 'PreState ; 'State .
                                subsort 'NeList`{PreState`} < 'List`{PreState`} .
                                subsort 'PreState < 'NeList`{PreState`} .
                                op '.List`{PreState`} : nil -> 'List`{PreState`} [ctor] .
                                op '_=/=_ : 'Universal 'Universal -> 'Bool [prec(51) poly(1 2) special(
                                  id-hook('EqualitySymbol, nil)
                                  term-hook('equalTerm, 'false.Bool)
                                  term-hook('notEqualTerm, 'true.Bool))] .
                                op '_==_ : 'Universal 'Universal -> 'Bool [prec(51) poly(1 2) special(
                                  id-hook('EqualitySymbol, nil)
                                  term-hook('equalTerm, 'true.Bool)
                                  term-hook('notEqualTerm, 'false.Bool))] .
                                op '_`,_ : 'List`{PreState`} 'List`{PreState`}   -> 'List`{PreState`}   [assoc ctor id('.List`{PreState`}.List`{PreState`})] .
                                op '_`,_ : 'List`{PreState`} 'NeList`{PreState`} -> 'NeList`{PreState`} [assoc ctor id('.List`{PreState`}.List`{PreState`})] .
                                op '_and_ : 'Bool 'Bool -> 'Bool [assoc comm prec(55)] .
                                op '_implies_ : 'Bool 'Bool -> 'Bool [prec(61) gather('e 'E)] .
                                op '_or_ : 'Bool 'Bool -> 'Bool [assoc comm prec(59)] .
                                op '_xor_ : 'Bool 'Bool -> 'Bool [assoc comm prec(57)] .
                                op 'a : nil -> 'PreState [none] .
                                op 'b : nil -> 'PreState [none] .
                                op 'c : nil -> 'PreState [none] .
                                op 'f : 'PreState -> 'State [none] .
                                op 'false : nil -> 'Bool [ctor special(
                                  id-hook('SystemFalse, nil))] .
                                op 'g : 'PreState -> 'State [none] .
                                op 'if_then_else_fi : 'Bool 'Universal 'Universal -> 'Universal [poly(2 3 0) special(
                                  id-hook('BranchSymbol, nil)
                                  term-hook('1, 'true.Bool)
                                  term-hook('2, 'false.Bool))] .
                                op 'not_ : 'Bool -> 'Bool [prec(53)] .
                                op 'true : nil -> 'Bool [ctor special(
                                  id-hook('SystemTrue, nil))] .
                                none
                                eq '_and_['A:Bool,'A:Bool] = 'A:Bool [none] .
                                eq '_and_['A:Bool,'_xor_['B:Bool,'C:Bool]] = '_xor_['_and_['A:Bool,'B:Bool],'_and_['A:Bool,'C:Bool]] [none] .
                                eq '_and_['false.Bool,'A:Bool] = 'false.Bool [none] .
                                eq '_and_['true.Bool,'A:Bool] = 'A:Bool [none] .
                                eq '_implies_['A:Bool,'B:Bool] = 'not_['_xor_['A:Bool,'_and_['A:Bool,'B:Bool]]] [none] .
                                eq '_or_['A:Bool,'B:Bool] = '_xor_['_and_['A:Bool,'B:Bool],'_xor_['A:Bool,'B:Bool]] [none] .
                                eq '_xor_['A:Bool,'A:Bool] = 'false.Bool [none] .
                                eq '_xor_['false.Bool,'A:Bool] = 'A:Bool [none] .
                                eq 'not_['A:Bool] = '_xor_['true.Bool,'A:Bool] [none] .
                                rl 'f['a.PreState] => 'f['b.PreState] [none] .
                                rl 'f['a.PreState] => 'g['c.PreState] [none] .
                                rl 'f['b.PreState] => 'f['c.PreState] [none] .
                                rl 'f['c.PreState] => 'f['a.PreState] [none] .
                              endm
                            )
               >
      ]
.


reduce

claim [ modules < .ModuleEnv >
        ( strategy < load-module('CYCLE) ; set-module('STATE, 'CYCLE) ; set-module('TRACE, 'CYCLE)
                   ; explore-all-with(rewrite)
                   ; clear-module-db
                   >
          state < 'f['a.PreState] >
          trace < .CTermSetTrace >
        reduces-to
          strategy < .Program >
          state < .CTermSet >
          trace < 4 | 0 |-> < 'f['a.PreState]                    , 'f['a.PreState] >
                      1 |-> < 'f['b.PreState] ;; 'g['c.PreState] , 'f['a.PreState] ;; 'f['b.PreState] ;; 'g['c.PreState] >
                      2 |-> < 'f['c.PreState]                    , 'f['a.PreState] ;; 'f['b.PreState] ;; 'f['c.PreState] ;; 'g['c.PreState] >
                      3 |-> < .CTermSet                          , 'f['a.PreState] ;; 'f['b.PreState] ;; 'f['c.PreState] ;; 'g['c.PreState] >
                >
        )
      ]

.

reduce

claim [ modules < .ModuleEnv >
        ( strategy < load-module('CYCLE) ; set-module('STATE, 'CYCLE) ; set-module('TRACE, 'CYCLE)
                   ; explore-all-with(narrow)
                   ; clear-module-db
                   >
          state < 'f['Y:PreState] >
          trace < .CTermSetTrace >
        reduces-to
          strategy < .Program >
          state < .CTermSet >
          trace < 3 | 0 |-> < 'f['Y:PreState] , 'f['Y:PreState] >
                      1 |-> < 'g['c.PreState] , 'f['Y:PreState] ;; 'g['c.PreState] >
                      2 |-> < .CTermSet       , 'f['Y:PreState] ;; 'g['c.PreState] >
                >
        )
      ]

.

reduce

claim [ modules < .ModuleEnv >
        ( strategy < load-module('NONDET-SCHEDULER) ; set-module('STATE, 'NONDET-SCHEDULER) ; set-module('TRACE, 'NONDET-SCHEDULER)
                   ; explore-all-with(rewrite)
                   ; clear-module-db
                   >
          state < '`{_`}['__['tb.Task, 'addTasks['__['ta.Task, 'tb.Task]]]] >
          trace < .CTermSetTrace >
        reduces-to
          strategy < .Program >
          state < .CTermSet >
          trace < 7 | 0 |-> < '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]]                                         , '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]] >
                      1 |-> < '_|_['tb.Task,'addTasks['__['ta.Task,'tb.Task]]] ;; '`{_`}['__['ta.Task,'tb.Task]]              , '_|_['tb.Task,'addTasks['__['ta.Task,'tb.Task]]] ;; '`{_`}['__['ta.Task,'tb.Task]] ;; '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]] >
                      2 |-> < '_|_['ta.Task,'tb.Task] ;; '_|_['tb.Task,'ta.Task] ;; '`{_`}['addTasks['__['ta.Task,'tb.Task]]] , '_|_['ta.Task,'tb.Task] ;; '_|_['tb.Task,'ta.Task] ;; '_|_['tb.Task,'addTasks['__['ta.Task,'tb.Task]]] ;; '`{_`}['__['ta.Task,'tb.Task]] ;; '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]] ;; '`{_`}['addTasks['__['ta.Task,'tb.Task]]] >
                      3 |-> < '`{_`}['ta.Task] ;; '`{_`}['tb.Task]                                                            , '_|_['ta.Task,'tb.Task] ;; '_|_['tb.Task,'ta.Task] ;; '_|_['tb.Task,'addTasks['__['ta.Task,'tb.Task]]] ;; '`{_`}['ta.Task] ;; '`{_`}['tb.Task] ;; '`{_`}['__['ta.Task,'tb.Task]] ;; '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]] ;; '`{_`}['addTasks['__['ta.Task,'tb.Task]]] >
                      4 |-> < '_|_['ta.Task,'.Tasks.Tasks] ;; '_|_['tb.Task,'.Tasks.Tasks]                                    , '_|_['ta.Task,'.Tasks.Tasks] ;; '_|_['ta.Task,'tb.Task] ;; '_|_['tb.Task,'.Tasks.Tasks] ;; '_|_['tb.Task,'ta.Task] ;; '_|_['tb.Task,'addTasks['__['ta.Task,'tb.Task]]] ;; '`{_`}['ta.Task] ;; '`{_`}['tb.Task] ;; '`{_`}['__['ta.Task,'tb.Task]] ;; '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]] ;; '`{_`}['addTasks['__['ta.Task,'tb.Task]]] >
                      5 |-> < '`{_`}['.Tasks.Tasks]                                                                           , '_|_['ta.Task,'.Tasks.Tasks] ;; '_|_['ta.Task,'tb.Task] ;; '_|_['tb.Task,'.Tasks.Tasks] ;; '_|_['tb.Task,'ta.Task] ;; '_|_['tb.Task,'addTasks['__['ta.Task,'tb.Task]]] ;; '`{_`}['.Tasks.Tasks] ;; '`{_`}['ta.Task] ;; '`{_`}['tb.Task] ;; '`{_`}['__['ta.Task,'tb.Task]] ;; '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]] ;; '`{_`}['addTasks['__['ta.Task,'tb.Task]]] >
                      6 |-> < .CTermSet                                                                                       , '_|_['ta.Task,'.Tasks.Tasks] ;; '_|_['ta.Task,'tb.Task] ;; '_|_['tb.Task,'.Tasks.Tasks] ;; '_|_['tb.Task,'ta.Task] ;; '_|_['tb.Task,'addTasks['__['ta.Task,'tb.Task]]] ;; '`{_`}['.Tasks.Tasks] ;; '`{_`}['ta.Task] ;; '`{_`}['tb.Task] ;; '`{_`}['__['ta.Task,'tb.Task]] ;; '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]] ;; '`{_`}['addTasks['__['ta.Task,'tb.Task]]] >
                >
        )
      ]

.

q
