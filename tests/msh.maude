load ../msh.maude
load ../systems/all-systems.maude

set include BOOL off .

fmod TEST-MODULE is
  sorts A B .
  subsort A < B .

  op a : -> A .
  op b : -> B .

  op f : B -> A .
  ---------------
  eq f(b) = a .
endfm

fmod TEST-STUFF is
  protecting MODULE-EXPRESSION .

  op initMOD : -> Module .
  eq initMOD = ( fmod 'TEST-MODULE is
                   nil
                   sorts 'A ; 'B .
                   subsort 'A < 'B .
                   op 'a : nil -> 'A [none] .
                   op 'b : nil -> 'B [none] .
                   op 'f : 'B  -> 'A [none] .
                   none
                   eq 'f['b.B] = 'a.A [none] .
                   none
                 endfm
               ) .

  op simpleStruct : Nat -> ModuleTemplate .
  eq simpleStruct(1) = (sorts svar('X) ; svar('Y) . subsort svar('X) < svar('Y) .) .
  eq simpleStruct(2) = (sorts 'A ; 'B . subsort 'A < 'B .) .
endfm

fmod MSH-TEST-HARNESS is
  extending MSH-EXTENDED .

  vars INIT CORRECT A A' : Analysis . var NeA : NeAnalysis .

  op claim : Analysis Analysis -> Analysis .
  op success : -> Analysis .

  op _reduces-to_ : Analysis Analysis -> [Analysis] [prec 98].
  ------------------------------------------------------------
  eq NeA (A reduces-to A')          = (NeA A) reduces-to (NeA A') .

  op failure [_] : Analysis -> [Analysis] [format(d d n n d)] .
  -------------------------------------------------------------
  eq failure [ NeA A reduces-to NeA A' ] = failure [ A reduces-to A' ] .

  op claim   [_] : Analysis -> [Analysis] [format(d d n n d)] .
  -------------------------------------------------------------
  ceq claim [ INIT reduces-to CORRECT ] = if A == CORRECT then success else failure [ A reduces-to CORRECT ] fi if A := INIT .
endfm

set print color on .

reduce

claim [ strategy < print("hello") >
        output < .Output >
      reduces-to
        strategy < .Program >
        output < print("hello") >
      ]
.

reduce

claim [ ( modules < .ModuleEnv >
          strategy < load-module('TEST-MODULE)
                   ; set-module('TEST-MODULE2, ('TEST-MODULE deriving List))
                   ; show-module('TEST-MODULE)
                   ; show-module('TEST-MODULE2)
                   >
          output < .Output >
        )

      reduces-to

        ( modules < 'TEST-MODULE |-> 'TEST-MODULE 'TEST-MODULE2 |-> ('TEST-MODULE deriving List)>
          strategy < .Program >
          output <   show-module( fmod 'TEST-MODULE is
                                    nil
                                    sorts 'A ; 'B .
                                    subsort 'A < 'B .
                                    op 'a : nil -> 'A [none] .
                                    op 'b : nil -> 'B [none] .
                                    op 'f : 'B  -> 'A [none] .
                                    none
                                    eq 'f['b.B] = 'a.A [none] .
                                    none
                                  endfm
                                )
                 ;;; show-module( fmod 'TEST-MODULE is
                                    nil
                                    sorts 'A ; 'B ; 'List < 'A > ; 'List < 'B > ; 'NeList < 'A > ; 'NeList < 'B > .
                                    subsort 'A < 'B .
                                    subsort 'A < ('NeList < 'A >) .
                                    subsort 'B < ('NeList < 'B >) .
                                    subsort ('List < 'A >) < ('List < 'B >) .
                                    subsort ('NeList < 'A >) < ('List < 'A >) .
                                    subsort ('NeList < 'A >) < ('NeList < 'B >) .
                                    subsort ('NeList < 'B >) < ('List < 'B >) .
                                    op 'a : nil -> 'A [none] .
                                    op 'b : nil -> 'B [none] .
                                    op 'f : 'B  -> 'A [none] .
                                    none
                                    eq 'f['b.B] = 'a.A [none] .
                                    none
                                  endfm
                                )
                 >
        )
      ]

.

reduce

claim [ modules < .ModuleEnv >
        ( strategy < load-module('CYCLE) ; set-module('STATE, 'CYCLE) ; set-module('TRACE, 'CYCLE)
                   ; explore-all-with(rewrite)
                   ; clear-module-db
                   >
          state < 'f['a.PreState] >
          trace < .CTermSetTrace >
        reduces-to
          strategy < .Program >
          state < .CTermSet >
          trace < 4 | 0 |-> < 'f['a.PreState]                    , 'f['a.PreState] >
                      1 |-> < 'f['b.PreState] ;; 'g['c.PreState] , 'f['a.PreState] ;; 'f['b.PreState] ;; 'g['c.PreState] >
                      2 |-> < 'f['c.PreState]                    , 'f['a.PreState] ;; 'f['b.PreState] ;; 'f['c.PreState] ;; 'g['c.PreState] >
                      3 |-> < .CTermSet                          , 'f['a.PreState] ;; 'f['b.PreState] ;; 'f['c.PreState] ;; 'g['c.PreState] >
                >
        )
      ]

.

reduce

claim [ modules < .ModuleEnv >
        ( strategy < load-module('CYCLE) ; set-module('STATE, 'CYCLE) ; set-module('TRACE, 'CYCLE)
                   ; explore-all-with(narrow)
                   ; clear-module-db
                   >
          state < 'f['Y:PreState] >
          trace < .CTermSetTrace >
        reduces-to
          strategy < .Program >
          state < .CTermSet >
          trace < 3 | 0 |-> < 'f['Y:PreState] , 'f['Y:PreState] >
                      1 |-> < 'g['c.PreState] , 'f['Y:PreState] ;; 'g['c.PreState] >
                      2 |-> < .CTermSet       , 'f['Y:PreState] ;; 'g['c.PreState] >
                >
        )
      ]

.

reduce

claim [ modules < .ModuleEnv >
        ( strategy < load-module('NONDET-SCHEDULER) ; set-module('STATE, 'NONDET-SCHEDULER) ; set-module('TRACE, 'NONDET-SCHEDULER)
                   ; explore-all-with(rewrite)
                   ; clear-module-db
                   >
          state < '`{_`}['__['tb.Task, 'addTasks['__['ta.Task, 'tb.Task]]]] >
          trace < .CTermSetTrace >
        reduces-to
          strategy < .Program >
          state < .CTermSet >
          trace < 7 | 0 |-> < '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]]                                         , '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]] >
                      1 |-> < '_|_['tb.Task,'addTasks['__['ta.Task,'tb.Task]]] ;; '`{_`}['__['ta.Task,'tb.Task]]              , '_|_['tb.Task,'addTasks['__['ta.Task,'tb.Task]]] ;; '`{_`}['__['ta.Task,'tb.Task]] ;; '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]] >
                      2 |-> < '_|_['ta.Task,'tb.Task] ;; '_|_['tb.Task,'ta.Task] ;; '`{_`}['addTasks['__['ta.Task,'tb.Task]]] , '_|_['ta.Task,'tb.Task] ;; '_|_['tb.Task,'ta.Task] ;; '_|_['tb.Task,'addTasks['__['ta.Task,'tb.Task]]] ;; '`{_`}['__['ta.Task,'tb.Task]] ;; '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]] ;; '`{_`}['addTasks['__['ta.Task,'tb.Task]]] >
                      3 |-> < '`{_`}['ta.Task] ;; '`{_`}['tb.Task]                                                            , '_|_['ta.Task,'tb.Task] ;; '_|_['tb.Task,'ta.Task] ;; '_|_['tb.Task,'addTasks['__['ta.Task,'tb.Task]]] ;; '`{_`}['ta.Task] ;; '`{_`}['tb.Task] ;; '`{_`}['__['ta.Task,'tb.Task]] ;; '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]] ;; '`{_`}['addTasks['__['ta.Task,'tb.Task]]] >
                      4 |-> < '_|_['ta.Task,'.Tasks.Tasks] ;; '_|_['tb.Task,'.Tasks.Tasks]                                    , '_|_['ta.Task,'.Tasks.Tasks] ;; '_|_['ta.Task,'tb.Task] ;; '_|_['tb.Task,'.Tasks.Tasks] ;; '_|_['tb.Task,'ta.Task] ;; '_|_['tb.Task,'addTasks['__['ta.Task,'tb.Task]]] ;; '`{_`}['ta.Task] ;; '`{_`}['tb.Task] ;; '`{_`}['__['ta.Task,'tb.Task]] ;; '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]] ;; '`{_`}['addTasks['__['ta.Task,'tb.Task]]] >
                      5 |-> < '`{_`}['.Tasks.Tasks]                                                                           , '_|_['ta.Task,'.Tasks.Tasks] ;; '_|_['ta.Task,'tb.Task] ;; '_|_['tb.Task,'.Tasks.Tasks] ;; '_|_['tb.Task,'ta.Task] ;; '_|_['tb.Task,'addTasks['__['ta.Task,'tb.Task]]] ;; '`{_`}['.Tasks.Tasks] ;; '`{_`}['ta.Task] ;; '`{_`}['tb.Task] ;; '`{_`}['__['ta.Task,'tb.Task]] ;; '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]] ;; '`{_`}['addTasks['__['ta.Task,'tb.Task]]] >
                      6 |-> < .CTermSet                                                                                       , '_|_['ta.Task,'.Tasks.Tasks] ;; '_|_['ta.Task,'tb.Task] ;; '_|_['tb.Task,'.Tasks.Tasks] ;; '_|_['tb.Task,'ta.Task] ;; '_|_['tb.Task,'addTasks['__['ta.Task,'tb.Task]]] ;; '`{_`}['.Tasks.Tasks] ;; '`{_`}['ta.Task] ;; '`{_`}['tb.Task] ;; '`{_`}['__['ta.Task,'tb.Task]] ;; '`{_`}['__['tb.Task,'addTasks['__['ta.Task,'tb.Task]]]] ;; '`{_`}['addTasks['__['ta.Task,'tb.Task]]] >
                >
        )
      ]

.
