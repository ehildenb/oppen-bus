load intersection .

fmod PURIFICATION is

  protecting META-LEVEL .
  protecting FVAR-CONCRETE .
  protecting FOFORMSIMPLIFY-IMPL .
  protecting CTERM-SET * ( op _;;_ to _;;;_ ) .
  protecting BREAK-EQATOMS .
  protecting INTERSECTION .
  
  op purify : FModule FModule EqConj -> EqConj .
  
  op purify : ModuleExpression ModuleExpression EqConj -> EqConj .
  vars MExp1 MExp2 : ModuleExpression .
  eq purify(MExp1, MExp2, E:EqConj)
   = purify(upModule(MExp1, true),
            upModule(MExp2, true),
            E:EqConj) .
  
  vars M M1 M2 M0 : FModule . 
  vars FV V : Variable .
  vars T T' T1 T2 T0 PT1 PT2 : Term .
  vars C C' C1 C2 : FOForm . var Q : Qid . vars TL TL' TL1 TL2 : TermList .
  
  eq purify(M1, M2, tt) = tt .
  eq purify(M1, M2, ff) = ff .
  eq purify(M1, M2, C1 /\ C2)
   = purify(M1, M2, C1) /\ purify(M1, M2, C2) .
  
  ---- (Case A) Both Lhs and Rhs are pure and from one module.
  ---- (Case A: equality)
  ----          Return Lhs ?= Rhs.
  ---- (Case A: disequality)
  ----          Return Lhs != Rhs.
  
  ceq purify(M1, M2, T1 ?= T2) = T1 ?= T2 
   if (wellFormed(M1, T1) and wellFormed(M1, T2))
   or (wellFormed(M2, T1) and wellFormed(M2, T2)) .
   
  ceq purify(M1, M2, T1 != T2) = T1 != T2 
   if (wellFormed(M1, T1) and wellFormed(M1, T2))
   or (wellFormed(M2, T1) and wellFormed(M2, T2)) .
  
  ---- (Case B) Lhs and Rhs are both not Variable.
    
  ceq purify(M1, M2, T1 ?= T2) 
    = break-eqatoms(M1, M2, T1 ?= T2) 
   if not (T1 :: Variable or T2 :: Variable) .
    
  ceq purify(M1, M2, T1 != T2) 
    = break-eqatoms(M1, M2, T1 != T2) 
   if not (T1 :: Variable or T2 :: Variable) .
   
   
   ---- (Case C) Lhs is a Variable and Rhs is not.
   ----          Purify the term Rhs w.r.t. the module of Lhs.
   
   eq purify(M1, M2, V ?= T)
     = if wellFormed(M1, V)
       then V ?= purifyTerm(M1, M2, T)
       else V ?= purifyTerm(M2, M1, T)
       fi .
       
   eq purify(M1, M2, V != T)
     = if wellFormed(M1, V)
       then V != purifyTerm(M1, M2, T)
       else V != purifyTerm(M2, M1, T)
       fi .
   
   op purifyTerm : Module Module Term -> CTerm .
   
   op purifyTerm : ModuleExpression ModuleExpression Term -> CTerm .
   eq purifyTerm(MExp1, MExp2, T)
    = purifyTerm(upModule(MExp1, true),
                 upModule(MExp2, true),
                 T) .
   
   op _?=_ : Term CTerm -> EqConj [ditto] .
   op _!=_ : Term CTerm -> EqConj [ditto] .
   
   eq T ?= T' | C = T ?= T' /\ C .
   eq T != T' | C = T != T' /\ C .
   
   ---- Define purifyTerm(M1, M2, T)
   
   ---- (Case A) T is a well-formed term in M1.
   ----          Simply returns T.
   
   ceq purifyTerm(M1, M2, T) = T
    if wellFormed(M1, T) .
    
   ---- (Case B) T is a well-formed term in M2.
   ----          Return JointVar /\ JointVar ?= T.
   
   ceq purifyTerm(M1, M2, T) = FV | FV ?= T 
    if wellFormed(M2, T) /\ FV := joint-variable(M1, M2, T) .
    
  
  ---- (Case C) T = Q[TL] is mixed-form.
  
  ---- If Q is not in the module to which we purify w.r.t.,
  ---- then first purify Q[TL] w.r.t. the other module (get T'),
  ---- and come up a joint variable for that.
  
  ceq purifyTerm(M1, M2, Q[TL])
    = V | C' /\ V ?= T'
  if (not hasOpQ(M1, Q)) 
  /\ T' | C' := purifyTerm(M2, M1, Q[TL])
  /\ V := joint-variable(M1, M2, T') .
  
  eq purifyTerm(M1, M2, Q[TL])
   = paux(M1, M2, Q, TL, empty, tt) .
  
  op paux : 
       Module      ---- Q is in this module
       Module      ---- the other module
       Qid         ---- Q is an op
       TermList    ---- terms that have been purified
       TermList    ---- terms that haven't been purified
       FOForm      ---- collective constraints
       -> CTerm .

  eq paux(M1, M2, Q, empty, TL', C)
   = Q[TL'] | C .
  
 ceq paux(M1, M2, Q, (T, TL), TL', C)
   = paux(M1, M2, Q, TL, (TL', T), C)
 if  wellFormed(M1, T) .
 
 ceq paux(M1, M2, Q, (T, TL), TL', C)
   = paux(M1, M2, Q, TL, (TL', T'), (C /\ C'))
 if  T' | C' := purifyTerm(M1, M2, T) .
   
endfm
