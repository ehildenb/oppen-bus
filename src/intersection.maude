--- Module Intersection
--- ===================

--- This module computes module intersections over `ModuleDeclSet`. The intersection
--- operation is lifted to `Module` via `asTemplate`.


load module-template.maude

fmod INTERSECTION is
  protecting MODULE-TEMPLATE * ( op _;;_ to _;;;_ ) .
  protecting RENAMING-EXPR-EVALUATION .

  var B : Bool . vars TL : TypeList . var T : Type . var AS : AttrSet . var OPD : OpDecl . var OPDS : OpDeclSet .
  vars MOD MOD' M0 : Module . vars ME ME' : ModuleExpression .
  vars Q Q' : Qid . vars H H' : Header . vars S S' : Sort . vars SS SS' : SortSet .
  vars NeMDS NeMDS' : NeModuleDeclSet . vars MDS MDS' MDS'' : ModuleDeclSet .

  op intersect : ModuleDeclSet ModuleDeclSet -> ModuleDeclSet [assoc comm id: none] .
  -----------------------------------------------------------------------------------
  eq intersect( NeMDS     , NeMDS' )     = none [owise] .
  eq intersect( NeMDS MDS , NeMDS MDS' ) = NeMDS intersect( MDS , MDS' ) .
  eq intersect( (sorts S ; SS .) MDS , (sorts S ; SS' .) MDS' ) = (sorts S .) intersect( (sorts SS .) MDS , (sorts SS' .) MDS' ) .

  op intersect : Module Module -> Module .
  ----------------------------------------
  eq intersect(MOD, MOD') = fromTemplate(resolveNames(getName(MOD) /\ getName(MOD')), intersect(asTemplate(MOD), asTemplate(MOD'))) .
  eq upModule(H /\ H', B) = intersect(upModule(H, B), upModule(H', B)) .


--- It will often be useful to know if a sort or an operator is in a
--- `ModuleDeclSet`.


  op _in_ : Sort ModuleDeclSet -> Bool .
  op _in_ : Qid  ModuleDeclSet -> Bool .
  --------------------------------------
  eq S in ( sorts SS . )            MDS = S in SS .
  eq Q in ( op Q : TL -> T [AS] . ) MDS = true .
  eq S in MDS = false [owise] .
  eq Q in MDS = false [owise] .


--- Joint Sorts
--- -----------

--- Calculating the joint sort of a sort `S` in connected components `C1` and `C2`
--- corresponding to modules `MOD` and `MOD'`:

--- -   If `S` is a sort of `C1 /\ C2`, return `S`;
--- -   If not, return the maximal sort in `C1 /\ C2`.


  op joint-sort : Sort Module           Module           -> Sort .
  op joint-sort : Sort ModuleExpression ModuleExpression -> Sort .
  op joint-sort : Sort ModuleDeclSet    ModuleDeclSet    -> Sort .
  ----------------------------------------------------------------
  eq  joint-sort(S, ME,  ME')  = joint-sort(S, upModule(ME /\ ME', true), upModule(ME /\ ME', true)) .
  eq  joint-sort(S, MOD, MOD') = joint-sort(S, asTemplate(MOD), asTemplate(MOD')) .
  ceq joint-sort(S, MDS, MDS') = joint-sort(S, MDS', MDS) if (not S in MDS) /\ S in MDS' .
  ceq joint-sort(S, MDS, MDS') = if S in MDS'' then S else #top-sort(MDS'') fi
                               if S in MDS /\ MDS'' := intersect(connected-component(MDS, (sorts S .)), MDS') .

  op #top-sort : ModuleDeclSet -> [Sort] .
  ----------------------------------------
  eq #top-sort( ( sorts S ; SS . )   MDS ) = top-sort( ( sorts S ; SS . )   MDS , S ) .
  eq #top-sort( ( subsort S < S' . ) MDS ) = top-sort( ( subsort S < S' . ) MDS , S ) .
endfm


--- Deterministic Variables
--- =======================

--- Having deterministically calculated variables makes many things much simpler.
--- This module calculates a variable for a given term by simply turning the term
--- into a string. This guarantees that if the same term is encountered twice, the
--- same variable will be generated.


fmod DETERMINISTIC-VARIABLES is
  protecting INTERSECTION .

  vars ME ME' : ModuleExpression . vars MOD MOD' : Module . var T : Term .

  op #string : TermList -> String .
  ---------------------------------
  eq #string(Q:Qid)                 = string(Q:Qid) .
  eq #string(Q:Qid[TL:TermList])    = #string(Q:Qid) + "[" + #string(TL:TermList) + "]" .  
  eq #string((T:Term, TL:TermList)) = #string(T:Term) + ", " + #string(TL:TermList) .

  op #qid : TermList -> Qid .
  ---------------------------
  eq #qid(TL:TermList) = qid(#string(TL:TermList)) .

  op #makeVariable : Qid    Sort -> Variable .
  op #makeVariable : String Sort -> Variable .
  --------------------------------------------
  eq #makeVariable(Name:Qid, S:Sort)    = qid("#makeVariable(" + string(Name:Qid) + "):" + string(S:Sort)) .
  eq #makeVariable(Name:String, S:Sort) = qid("#makeVariable(" + Name:String + "):" + string(S:Sort)) .

  op joint-variable : ModuleExpression ModuleExpression Term -> Variable .
  ------------------------------------------------------------------------
  eq joint-variable(ME, ME', T) = joint-variable(upModule(ME, true), upModule(ME', true), T) .

  op joint-variable : Module Module Term -> Variable .
  ----------------------------------------------------
  eq joint-variable(MOD, MOD', T) = if wellFormed(MOD, T) then #makeVariable(#string(T), joint-sort(leastSort(MOD, T), MOD, MOD'))
                                                          else #makeVariable(#string(T), joint-sort(leastSort(MOD', T), MOD, MOD'))
                                    fi .
endfm


--- Breaking Equalities
--- ===================

--- Breaking equality atoms means taking an equality atom between terms of different
--- modules and reforming them:

--- -   `T ?= T'` goes to `x ?= T /\ x ?= T'` for `x` a variable of sort common to
---     `T` and `T'`.
--- -   `T != T'` goes to `x ?= T /\ x != T'` for `x` a variable of sort greater
---     than that `T'`.


fmod BREAK-EQATOMS is
    protecting DETERMINISTIC-VARIABLES .

    vars EqC EqC' : EqConj . vars MOD MOD' : Module . vars ME ME' : ModuleExpression .
    vars T T' : Term . var NV : Variable .

    op break-eqatoms : Module Module EqConj -> EqConj .
    op break-eqatoms : ModuleExpression ModuleExpression EqConj -> EqConj .
    -----------------------------------------------------------------------
    eq break-eqatoms(ME,  ME',  EqC)         = break-eqatoms(upModule(ME, true), upModule(ME', true), EqC) .
    eq break-eqatoms(MOD, MOD', EqC /\ EqC') = break-eqatoms(MOD, MOD', EqC) /\ break-eqatoms(MOD, MOD', EqC') .

    ceq break-eqatoms(MOD, MOD', T ?= T') = T ?= NV /\ T' ?= NV if not (T :: Variable or T' :: Variable)
                                                                /\ NV := joint-variable(MOD, MOD', T) .
    ceq break-eqatoms(MOD, MOD', T != T') = T ?= NV /\ T' != NV if not (T :: Variable or T' :: Variable)
                                                                /\ NV := joint-variable(MOD, MOD', T)
                                                                /\ sortLeq(MOD, leastSort(MOD, T), leastSort(MOD, NV)) .
    ceq break-eqatoms(MOD, MOD', T != T') = T ?= NV /\ T' != NV if not (T :: Variable or T' :: Variable)
                                                                /\ NV := joint-variable(MOD, MOD', T) 
                                                                /\ sortLeq(MOD', leastSort(MOD', T), leastSort(MOD', NV)) .
endfm

