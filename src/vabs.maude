--- Variable Abstraction
--- ====================

--- Variable abstraction reduces a conjunction of equality atoms to the cases:

--- -   `x ?= T` and `x != T` where `x` is a variable of the same sort as term `T`.

--- VARIABLE ABSTRACTION

--- Input: Two modules M1, M2, and an Equational Conjunction: a conjunction of
--- equations of the form T ?= T' and T != T'. Optimally intersectable signatures
--- are assumed.

--- Output: A new Equational Conjunction, where each Equational Atom is of the form
--- "T1 = T2", where either T1 or T2 (or both) is a variable, and the other is of
--- the form f(V1, ..., Vn) for variables V1 through Vn.


load ../src/intersection.maude

fmod VABS is
    pr FOFORM .
    pr FOFORMSIMPLIFY-IMPL .
    pr BREAK-EQATOMS .

    vars V FV : Variable . var C : Constant . var Q : Qid . vars T T' T'' : Term .
    vars TL TL' : TermList . vars NeTL NeTL' : NeTermList . 
    var ME : ModuleExpression . var M : Module .
    var EqA : EqAtom . vars EqC EqC' : EqConj . var TA : TruthAtom .

    op vabs : ModuleExpression EqConj -> [EqConj] .
    -----------------------------------------------
    eq vabs(ME, EqC) = vabs(upModule(ME, true), EqC) .


--- `abstracted : Term -> Bool` returns true if the current is abstracted.


    op abstracted : Term -> Bool .
    ------------------------------
    eq  abstracted(T)             = true [owise] .
    ceq abstracted(Q[TL, T, TL']) = false if not (T :: Variable) .


--- The operation `vabs : Module EqConj -> EqConj` takes in an equational
--- conjunction and variable abstracts all the equational atoms.


    op vabs : Module EqConj -> [EqConj] .
    -------------------------------------
    eq  vabs(M, EqC /\ EqC') = vabs(M, EqC) /\ vabs(M, EqC') .
    ceq vabs(M, V ?= T)      = V ?= T if abstracted(T) .
    ceq vabs(M, V != T)      = V != T if abstracted(T) .


--- If the top terms in the equality atom are both not variables and abstracted,
--- then `break-eqatoms` is used to make it a conjunct of simple equalities.


    ceq vabs(M, T ?= T') = break-eqatoms(M, M, T ?= T') if not (T :: Variable or T' :: Variable) /\ abstracted(T) /\ abstracted(T') .
    ceq vabs(M, T != T') = break-eqatoms(M, M, T != T') if not (T :: Variable or T' :: Variable) /\ abstracted(T) /\ abstracted(T') .


--- If there is a non-variable subterm, it is extracted as an equality. Both the
--- remaining subterms and the new equality are variable abstracted.


    ceq vabs(M, Q[TL, T, TL'] ?= T') = vabs(M, Q[TL, FV, TL'] ?= T') /\ vabs(M, FV ?= T) if not (T :: Variable) /\ FV := joint-variable(M, M, T) .
    ceq vabs(M, Q[TL, T, TL'] != T') = vabs(M, Q[TL, FV, TL'] != T') /\ vabs(M, FV ?= T) if not (T :: Variable) /\ FV := joint-variable(M, M, T) .
endfm


--- ### Examples

--- This is a sampling of the test cases in `tests/test-modules.maude` with a more
--- human-readable output, using this module:

--- For more test cases using more complex modules, see `tests/test-modules.maude`.
