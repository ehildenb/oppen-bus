load universal-construction.maude
load foform.maude
load ../tests/intersection.maude

fmod VARIABLE-ABSTRACTION is

    extending MODULE-EXPRESSION .
    extending FOFORM .

    op VABS : -> ModUniversalConstruction .

    vars M1 M2 : Qid .

    vars V F T T' TL TL' NV : Variable .

    ceq VABS < M1 , M2 >
      = exists ( pr 'FOFORMSIMPLIFY-IMPL .
                 pr M1 .
                 pr M2 .
                 pr 'FVAR-CONCRETE . )
               ( op 'vabs : 'EqConj -> 'EqConj [none] . )
               ( eq 'vabs['_?=_[T, T']] = '_?=_[T, T'] [owise] .

                ceq 'vabs['_?=_[T, T']] = '_/\_['vabs['_?=_[T, NV]],'vabs['_?=_[T', NV]]] 
                 if 'not_['_or_['_::`Variable[T], '_::`Variable[T']]] = 'true.Bool
                 /\ NV := 'joint-variable['upModule[upTerm(M1), 'false.Bool], 'upModule[upTerm(M2), 'false.Bool], T] [none] .

                ceq 'vabs['_?=_[V, '_`[_`][F, '_`,_[TL, T, TL']]]]
                  = '_/\_['vabs['_?=_[T, NV]], 'vabs['_?=_[V, '_`[_`][F,'_`,_[TL, NV, TL']]]]]
                 if 'not_['_::`Variable[T]] = 'true.Bool 
                 /\ NV := 'joint-variable['upModule[upTerm(M1), 'false.Bool], 'upModule[upTerm(M2), 'false.Bool], T] [none] .

                ceq 'vabs['_!=_[V, '_`[_`][F, '_`,_[TL, T, TL']]]]
                  = '_/\_['vabs['_?=_[T, NV]], 'vabs['_!=_[V, '_`[_`][F,'_`,_[TL, NV, TL']]]]] 
                 if 'not_['_::`Variable[T]] = 'true.Bool 
                 /\ NV := 'joint-variable['upModule[upTerm(M1), 'false.Bool], 'upModule[upTerm(M2), 'false.Bool], T] [none] . )
        
        if V := var('V, 'Variable)
        /\ F := var('F, 'Qid)
        /\ T := var('T, 'Term)
        /\ T' := var('T', 'Term)
        /\ TL := var('TL, 'TermList)
        /\ TL' := var('TL', 'TermList)
        /\ NV := var('NV, 'Variable) .
endfm

fmod VABS is
    pr FOFORM .
    pr TEST-MODULE .
    pr FVAR-CONCRETE .

    vars V NV : Variable .
    var F : Qid .
    vars T T' : Term .
    vars TL TL' : TermList .

    op vabs : EqConj -> EqConj .
    ceq vabs(T ?= T') = vabs(T ?= NV) /\ vabs(T' ?= NV)
      if not (T :: Variable or T' :: Variable)
      /\ NV := joint-variable(upModule('TEST-MODULE, false), upModule('TEST-MODULE, false), T) .
    ceq vabs(F[TL, T, TL'] ?= V)
      = vabs(F[TL, NV, TL'] ?= V) /\ vabs(NV ?= T)
      if not (T :: Variable) 
      /\ NV := joint-variable(upModule('TEST-MODULE, false), upModule('TEST-MODULE, false), T) .
    ceq vabs(F[TL, T, TL'] != V)
      = vabs(F[TL, NV, TL'] != V) /\ vabs(NV ?= T)
      if not (T :: Variable) 
      /\ NV := joint-variable(upModule('TEST-MODULE, false), upModule('TEST-MODULE, false), T) .
    eq vabs(T ?= T') = T ?= T' [owise] .
endfm
    
reduce upModule('VABS, false) .
reduce vabs('x:A ?= 'f['a.A]) .
    
reduce in VARIABLE-ABSTRACTION : resolveNames(#upModule('TEST-MODULE deriving VABS < 'TEST-MODULE, 'TEST-MODULE >)) .
reduce in VARIABLE-ABSTRACTION : wellFormed(resolveNames(#upModule('TEST-MODULE deriving VABS < 'TEST-MODULE, 'TEST-MODULE >))) .
reduce downTerm(getTerm(metaReduce( resolveNames(#upModule('TEST-MODULE deriving VABS < 'TEST-MODULE, 'TEST-MODULE >))
                                  , 'vabs[upTerm('x:A ?= 'f['a.A])])), ff) .
reduce downTerm(getTerm(metaReduce( resolveNames(#upModule('TEST-MODULE deriving VABS < 'TEST-MODULE, 'TEST-MODULE >))
                                  , 'vabs[upTerm('f['f['a.A]] ?= 'f['a.A])])), ff) .
*** reduce downTerm(getTerm(metaReduce( resolveNames(#upModule('TEST-MODULE deriving VABS < 'TEST-MODULE >))
***                                   , 'vabs['_/\_[upTerm('f['f['a.A]] ?= 'f['a.A]), upTerm('f['f['a.A]] ?= 'f['a.A])]])), ff) .

