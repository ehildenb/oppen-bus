
load universal-construction.maude
load foform.maude
load ../tests/intersection.maude

fmod TEST-MODULE is
    sorts A B .
    subsort A < B .
    
    op a : -> A .
    op b : -> B .
    
    op f : B -> A .
    ---------------
    eq f(b) = a .
endfm

    
fmod VABS-SPEC is

    extending FOFORM .
    extending TEST-MODULE .

    var V : Variable .
    var NeTL : NeTermList .

    op variableList? : NeTermList -> Bool .
    op vabs : EqConj -> EqConj .

    eq variableList?(V) = true .
    eq variableList?((V, NeTL)) = variableList?(NeTL) .

endfm


fmod VARIABLE-ABSTRACTION is

    extending MODULE-EXPRESSION .
    extending FOFORM .

    op VABS : -> ModUniversalConstruction .

    var M : Qid .

    vars V F T T' TL TL' NV : Variable .

    ceq VABS < M >
      = exists ( pr 'FOFORMSIMPLIFY-IMPL .
                 pr M .
                 pr 'FVAR-CONCRETE . )
               ( op 'vabs : 'EqConj -> 'EqConj [none] . )
               ( eq 'vabs['_?=_[T, T']] = '_?=_[T, T'] [owise] .

                ceq 'vabs['_?=_[T, T']] = '_/\_['vabs['_?=_[T, NV]],'vabs['_?=_[T', NV]]] 
                 if 'not_['_or_['_::`Variable[T], '_::`Variable[T']]] = 'true.Bool
                 /\ NV := 'joint-variable['upModule[upTerm(M), 'false.Bool], 'upModule[upTerm(M), 'false.Bool], T] [none] .

                ceq 'vabs['_?=_[V, '_`[_`][F, '_`,_[TL, T, TL']]]]
                  = '_/\_['vabs['_?=_[T, NV]], 'vabs['_?=_[V, '_`[_`][F,'_`,_[TL, NV, TL']]]]]
                 if 'not_['_::`Variable[T]] = 'true.Bool 
                 /\ NV := 'joint-variable['upModule[upTerm(M), 'false.Bool], 'upModule[upTerm(M), 'false.Bool], T] [none] .

                ceq 'vabs['_!=_[V, '_`[_`][F, '_`,_[TL, T, TL']]]]
                  = '_/\_['vabs['_?=_[T, NV]], 'vabs['_!=_[V, '_`[_`][F,'_`,_[TL, NV, TL']]]]] 
                 if 'not_['_::`Variable[T]] = 'true.Bool 
                 /\ NV := 'joint-variable['upModule[upTerm(M), 'false.Bool], 'upModule[upTerm(M), 'false.Bool], T] [none] . )
        
        if V := var('V, 'Variable)
        /\ F := var('F, 'Qid)
        /\ T := var('T, 'Term)
        /\ T' := var('T', 'Term)
        /\ TL := var('TL, 'TermList)
        /\ TL' := var('TL', 'TermList)
        /\ NV := var('NV, 'Variable) .
endfm

fmod VABS is
    pr FOFORM .
    pr TEST-MODULE .
    pr FVAR-CONCRETE .

    vars V NV : Variable .
    var F : Qid .
    vars T T' : Term .
    vars TL TL' : TermList .

    op vabs : EqConj -> EqConj .
    ceq vabs(T ?= T') = vabs(T ?= NV) /\ vabs(T' ?= NV)
      if not (T :: Variable or T' :: Variable)
      /\ NV := joint-variable(upModule('TEST-MODULE, false), upModule('TEST-MODULE, false), T) .
    ceq vabs(F[TL, T, TL'] ?= V)
      = vabs(F[TL, NV, TL'] ?= V) /\ vabs(NV ?= T)
      if not (T :: Variable) 
      /\ NV := joint-variable(upModule('TEST-MODULE, false), upModule('TEST-MODULE, false), T) .
    ceq vabs(F[TL, T, TL'] != V)
      = vabs(F[TL, NV, TL'] != V) /\ vabs(NV ?= T)
      if not (T :: Variable) 
      /\ NV := joint-variable(upModule('TEST-MODULE, false), upModule('TEST-MODULE, false), T) .
    eq vabs(T ?= T') = T ?= T' [owise] .
endfm
    
reduce upModule('VABS, false) .
reduce vabs('x:A ?= 'f['a.A]) .
    
reduce in VARIABLE-ABSTRACTION : resolveNames(#upModule('TEST-MODULE deriving VABS)) .
reduce in VARIABLE-ABSTRACTION : wellFormed(resolveNames(#upModule('TEST-MODULE deriving VABS))) .
reduce downTerm(getTerm(metaReduce( resolveNames(#upModule('TEST-MODULE deriving VABS))
                                  , 'vabs[upTerm('x:A ?= 'f['a.A])])), ff) .
reduce downTerm(getTerm(metaReduce( resolveNames(#upModule('TEST-MODULE deriving VABS))
                                  , 'vabs[upTerm('f['f['a.A]] ?= 'f['a.A])])), ff) .
